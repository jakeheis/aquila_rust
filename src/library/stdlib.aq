builtin def malloc(count: int): ptr any;
builtin def realloc(location: ptr any, count: int): ptr any;
builtin def strlen(location: ptr byte): int;
builtin def memcpy(to: ptr any, from: ptr any, length: int): int;
builtin def sizeof(object: any): int;
builtin def exit(code: int);

builtin def ptr_offset(pointer: ptr any, distance: int): ptr any;
builtin def _read_line(): ptr byte;

type Memory {

    builtin meta def size[T](): int;

    meta def size_instance[T](instance: T): int {
        return sizeof(instance);
    }
    
    meta def allocate[T](): ptr T {
        return cast[ptr T](malloc(size[T]()));
    }

    meta def allocate_block[T](count: int): ptr T {
        return cast[ptr T](malloc(size[T]() * count));
    }

    meta def reallocate[T](current: ptr T, count: int): ptr T {
        return cast[ptr T](realloc(current, count * sizeof(T)));
    }

    meta def copy[T](from: ptr T, to: ptr T) {
        copy_block[T](from, to, 1);
    }

    meta def copy_block[T](from: ptr T, to: ptr T, count: int) {
        memcpy(to, from, count * sizeof(T));
    }

    meta def offset[T](pointer: ptr T, count: int): ptr T {
        return cast[ptr T](ptr_offset(pointer, count * sizeof(T)));
    }

}

pub builtin def print(obj: any);

pub def read_line(): String {
    return String.from(_read_line());
}

pub def fatal_error(message: ptr byte, #caller) {
    fatal_error_location(message, caller);
}

pub def fatal_error_location(message: ptr byte, location: ptr byte) {
    print(String.from("Fatal error: ").append_literal(message).storage);
    print("");
    print(location);
    exit(1);
}

/*
type SizedCollectionIterator {
    let location: ptr void;
    let count: int;
    let offset: int;
}
*/

pub type String {
    
    let storage: ptr byte;
    let size: int;

    pub meta def from(lit: ptr byte): String {
        let size = strlen(lit) + 1;
        return String(lit, size);
    }

    pub def append_literal(lit: ptr byte): String {
        let new_size = size + strlen(lit);

        let new_storage = Memory.allocate_block[byte](new_size);
        Memory.copy_block[byte](storage, new_storage, size - 1);

        let second_part = Memory.offset[byte](new_storage, size - 1);
        Memory.copy_block[byte](lit, second_part, strlen(lit) + 1);

        return String(new_storage, new_size);
    }

    pub def append(string: String): String {
        return append_literal(string.storage);
    }

}

pub type Vec[T] {

    let storage: ptr T;
    pub let count: int;
    pub let capacity: int;
    let element_size: int;

    pub meta def new(): Vec[T] {
        let storage = Memory.allocate_block[T](10);
        return Vec[T](storage, 0, 10, Memory.size[T]());
    }

    pub def insert(object: T) {
        if count == capacity {
            capacity = capacity * 2;
            storage = Memory.reallocate[T](storage, capacity);
        }

        copy_in(count, &object);

        count = count + 1;
    }

    pub def get(index: int, #caller): ptr T {
        if index >= count {
            fatal_error_location("index out of bounds", caller);
        }
        return Memory.offset[T](storage, index);
    }

    pub def first(): Optional[ptr T] {
        if count > 0 {
            return Optional[ptr T].some(storage);
        } else {
            return Optional[ptr T].none();
        }
    }

    pub def replace(index: int, object: T, #caller) {
        if index > count {
            fatal_error_location("index out of bounds", caller);
        }
        if index == count {
            insert(object);
        } else {
            copy_in(index, &object);
        }
    }

    pub def pop(#caller): T {
        if count == 0 {
            fatal_error_location("can't pop from empty vector", caller);
        }
        count = count - 1;
        return *Memory.offset[T](storage, count);
    }

    def copy_in(index: int, object: ptr T) {
        let location = Memory.offset[T](storage, index);
        Memory.copy[T](object, location);
    }

}

pub type Optional[T] {
    let _is_some: bool;
    let object: ptr T;

    pub meta def some(object: T): Optional[T] {
        let location = Memory.allocate[T]();
        Memory.copy[T](&object, location);
        return Optional[T](true, location);
    }

    pub meta def none(): Optional[T] {
        return Optional[T](false, cast[ptr T](&0));
    }

    pub def is_some(): bool {
        return _is_some;
    }

    pub def is_none(): bool {
        return !_is_some;
    }

    pub def unwrap(#caller): ptr T {
        if _is_some == false {
            fatal_error_location("unwrapped a nil value", caller);
        }
        return object;
    }
}

trait Writable {
    def write();
}

impl String: Writable {
    def write() {
        print(storage);
    }
}

impl Optional: Writable {
    def write() {
        if _is_some {
            print("Some");
        } else {
            print("None");
        }
    }
}

// trait Indexable {
//     type T; 
//     def at_index(): ptr T;
// }
