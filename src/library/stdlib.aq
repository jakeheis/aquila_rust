builtin def malloc(count: int): ptr any {}
builtin def realloc(location: ptr any, count: int): ptr any {}
builtin def strlen(location: ptr byte): int {}
builtin def memcpy(to: ptr any, from: ptr any, length: int): int {}
builtin def sizeof(object: any): int {}
builtin def exit(code: int) {}

builtin def ptr_offset(pointer: ptr any, distance: int): ptr any {}
builtin def _read_line(): ptr byte {}

type Memory {

    meta def size[T](): int {
        return sizeof(T);
    }

    meta def size_instance[T](instance: T): int {
        return sizeof(instance);
    }
    
    meta def allocate[T](): ptr T {
        return cast[ptr T](malloc(size[T]()));
    }

    meta def allocate_block[T](count: int): ptr T {
        return cast[ptr T](malloc(size[T]() * count));
    }

    meta def reallocate[T](current: ptr T, count: int): ptr T {
        return cast[ptr T](realloc(current, count * sizeof(T)));
    }

    meta def copy[T](from: ptr T, to: ptr T) {
        copy_block[T](from, to, 1);
    }

    meta def copy_block[T](from: ptr T, to: ptr T, count: int) {
        memcpy(to, from, count * sizeof(T));
    }

    meta def offset[T](pointer: ptr T, count: int): ptr T {
        return cast[ptr T](ptr_offset(pointer, count * sizeof(T)));
    }

}

def read_line(): String {
    return String.from(_read_line());
}

def fatal_error(message: ptr byte) {
    print String.from("Fatal error: ").append_literal(message).storage;
    exit(1);
}

/*
type SizedCollectionIterator {
    let location: ptr void;
    let count: int;
    let offset: int;
}
*/

type String {
    
    let storage: ptr byte;
    let size: int;

    meta def from(lit: ptr byte): String {
        let size = strlen(lit) + 1;
        return String(lit, size);
    }

    def append_literal(lit: ptr byte): String {
        let new_size = size + strlen(lit);

        let new_storage = Memory.allocate_block[byte](new_size);
        Memory.copy_block(storage, new_storage, size - 1);

        let second_part = Memory.offset(new_storage, size - 1);
        Memory.copy_block(lit, second_part, strlen(lit) + 1);

        return String(new_storage, new_size);
    }

    def append(string: String): String {
        return append_literal(string.storage);
    }

    def print_str() {
        print storage;
    }

}

type Vec[T] {

    let storage: ptr T;
    let count: int;
    let capacity: int;
    let element_size: int;

    meta def new(): Vec[T] {
        let storage = Memory.allocate_block[T](10);
        return Vec[T](storage, 0, 0, Memory.size[T]());
    }

    def insert(object: T) {
        insert_ptr(&object);
    }

    def insert_ptr(object: ptr T) {
        if count == capacity {
            capacity = capacity * 2;
            storage = Memory.reallocate(cast[ptr T](storage), capacity);
        }

        let insertion_location = Memory.offset(cast[ptr T](storage), count);
        Memory.copy(object, insertion_location);

        count = count + 1;
    }

    def get(index: int): ptr T {
        return Memory.offset(cast[ptr T](storage), index);
    }

}

trait Indexable {
    def at_index[T](): ptr T;
}
