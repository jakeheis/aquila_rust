// def add[T](lhs: T, rhs: T): T {
//     return rhs;
// }

// let num = add[int](3, 4);

// let str = add[ptr byte]("hi", "byte");

let dyn = String.literal("hello");

let combo1 = dyn.append_literal(" world");

/// -> hello world
print(combo1);

let combo2 = combo1.append_literal(" ag");

/// -> hello world ag
print(combo2);

/// -> hello world again
print(dyn.append_literal(" world").append_literal(" again"));


type Adder[T] {
    let lhs: T;
    let rhs: T;

    def pick(): T {
      return rhs;
    }
}

let adder_of_vecs = Adder[Vec[int]](Vec[int].new(), Vec[int].new());
adder_of_vecs.lhs.insert(4);
adder_of_vecs.rhs.insert(2);

def hello() {
  let z = Vec[int].new();
  if true {
    let a = Vec[bool].new();
  } else {
    let b = Vec[byte].new();
    return;
  }
  let c = Vec[ptr byte].new();
}

hello();

// let heap = box Adder[int](3, 4);
// let stack = Adder[ptr byte]("hi", "byte");

// def add_one(i: ref Adder[int], r: ref Adder[int]): int {
//     return i.pick() + r.pick();
// }

// add_one(heap, ref stack);

// def keep_one(i: box Adder[int], r: box Adder[int]): int {
//     return i.pick() + r.pick();
// }

// let uno = box 1;
// let duo = box 2;

// let vector = Vec[int].new();
// vector.insert(2);
// vector.insert(4);

// let vec = Vec[int].heap();


// print(vector);

// let a = 4 + 5;
// print a;

// let adder = Adder(1, 2);
// adder.sum(false, 4, a);

// while a > 6 {
//   print a;
//   a = a - 1;
// }

/*
enum Hello {
    case one;
    case two;
}

def fib(num: int): int {
  if num == 0 {
    return 0;
  }
  if num == 1 {
    return 1;
  }
  return fib(num - 2) + fib(num - 1);
}

print fib(1);
print;
print fib(3);
print;
print fib(5);
*/
